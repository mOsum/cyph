var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { SourceExpressions, moduleRef } from './source_module';
import { ChangeDetectorJITGenerator } from 'angular2/src/core/change_detection/change_detection_jit_generator';
import { AbstractChangeDetector } from 'angular2/src/core/change_detection/abstract_change_detector';
import { ChangeDetectionUtil } from 'angular2/src/core/change_detection/change_detection_util';
import { ChangeDetectorState } from 'angular2/src/core/change_detection/constants';
import { createChangeDetectorDefinitions } from './change_definition_factory';
import { IS_DART, CONST_EXPR } from 'angular2/src/facade/lang';
import { ChangeDetectorGenConfig, DynamicProtoChangeDetector } from 'angular2/src/core/change_detection/change_detection';
import { Codegen } from 'angular2/src/transform/template_compiler/change_detector_codegen';
import { MODULE_SUFFIX } from './util';
import { Injectable } from 'angular2/src/core/di';
const ABSTRACT_CHANGE_DETECTOR = 'AbstractChangeDetector';
const UTIL = 'ChangeDetectionUtil';
const CHANGE_DETECTOR_STATE = 'ChangeDetectorState';
export const CHANGE_DETECTION_JIT_IMPORTS = CONST_EXPR({
    'AbstractChangeDetector': AbstractChangeDetector,
    'ChangeDetectionUtil': ChangeDetectionUtil,
    'ChangeDetectorState': ChangeDetectorState
});
var ABSTRACT_CHANGE_DETECTOR_MODULE = moduleRef(`package:angular2/src/core/change_detection/abstract_change_detector${MODULE_SUFFIX}`);
var UTIL_MODULE = moduleRef(`package:angular2/src/core/change_detection/change_detection_util${MODULE_SUFFIX}`);
var PREGEN_PROTO_CHANGE_DETECTOR_MODULE = moduleRef(`package:angular2/src/core/change_detection/pregen_proto_change_detector${MODULE_SUFFIX}`);
var CONSTANTS_MODULE = moduleRef(`package:angular2/src/core/change_detection/constants${MODULE_SUFFIX}`);
export let ChangeDetectionCompiler = class {
    constructor(_genConfig) {
        this._genConfig = _genConfig;
    }
    compileComponentRuntime(componentType, strategy, parsedTemplate) {
        var changeDetectorDefinitions = createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);
        return changeDetectorDefinitions.map(definition => this._createChangeDetectorFactory(definition));
    }
    _createChangeDetectorFactory(definition) {
        var proto = new DynamicProtoChangeDetector(definition);
        return () => proto.instantiate();
    }
    compileComponentCodeGen(componentType, strategy, parsedTemplate) {
        var changeDetectorDefinitions = createChangeDetectorDefinitions(componentType, strategy, this._genConfig, parsedTemplate);
        var factories = [];
        var index = 0;
        var sourceParts = changeDetectorDefinitions.map(definition => {
            var codegen;
            var sourcePart;
            // TODO(tbosch): move the 2 code generators to the same place, one with .dart and one with .ts
            // suffix
            // and have the same API for calling them!
            if (IS_DART) {
                codegen = new Codegen(PREGEN_PROTO_CHANGE_DETECTOR_MODULE);
                var className = `_${definition.id}`;
                var typeRef = (index === 0 && componentType.isHost) ?
                    'dynamic' :
                    `${moduleRef(componentType.moduleUrl)}${componentType.name}`;
                codegen.generate(typeRef, className, definition);
                factories.push(`${className}.newChangeDetector`);
                sourcePart = codegen.toString();
            }
            else {
                codegen = new ChangeDetectorJITGenerator(definition, `${UTIL_MODULE}${UTIL}`, `${ABSTRACT_CHANGE_DETECTOR_MODULE}${ABSTRACT_CHANGE_DETECTOR}`, `${CONSTANTS_MODULE}${CHANGE_DETECTOR_STATE}`);
                factories.push(`function() { return new ${codegen.typeName}(); }`);
                sourcePart = codegen.generateSource();
            }
            index++;
            return sourcePart;
        });
        return new SourceExpressions(sourceParts, factories);
    }
};
ChangeDetectionCompiler = __decorate([
    Injectable(), 
    __metadata('design:paramtypes', [ChangeDetectorGenConfig])
], ChangeDetectionCompiler);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbmdlX2RldGVjdG9yX2NvbXBpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGlmZmluZ19wbHVnaW5fd3JhcHBlci1vdXRwdXRfcGF0aC13M0RSbFhKaS50bXAvYW5ndWxhcjIvc3JjL2NvbXBpbGVyL2NoYW5nZV9kZXRlY3Rvcl9jb21waWxlci50cyJdLCJuYW1lcyI6WyJDaGFuZ2VEZXRlY3Rpb25Db21waWxlciIsIkNoYW5nZURldGVjdGlvbkNvbXBpbGVyLmNvbnN0cnVjdG9yIiwiQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudFJ1bnRpbWUiLCJDaGFuZ2VEZXRlY3Rpb25Db21waWxlci5fY3JlYXRlQ2hhbmdlRGV0ZWN0b3JGYWN0b3J5IiwiQ2hhbmdlRGV0ZWN0aW9uQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudENvZGVHZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztPQUNPLEVBQUMsaUJBQWlCLEVBQUUsU0FBUyxFQUFDLE1BQU0saUJBQWlCO09BQ3JELEVBQUMsMEJBQTBCLEVBQUMsTUFBTSxtRUFBbUU7T0FDckcsRUFBQyxzQkFBc0IsRUFBQyxNQUFNLDZEQUE2RDtPQUMzRixFQUFDLG1CQUFtQixFQUFDLE1BQU0sMERBQTBEO09BQ3JGLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSw4Q0FBOEM7T0FFekUsRUFBQywrQkFBK0IsRUFBQyxNQUFNLDZCQUE2QjtPQUNwRSxFQUFDLE9BQU8sRUFBYyxVQUFVLEVBQUMsTUFBTSwwQkFBMEI7T0FFakUsRUFBQyx1QkFBdUIsRUFBNEIsMEJBQTBCLEVBQTBCLE1BQU0scURBQXFEO09BR25LLEVBQUMsT0FBTyxFQUFDLE1BQU0sa0VBQWtFO09BQ2pGLEVBQUMsYUFBYSxFQUFDLE1BQU0sUUFBUTtPQUM3QixFQUFDLFVBQVUsRUFBQyxNQUFNLHNCQUFzQjtBQUUvQyxNQUFNLHdCQUF3QixHQUFHLHdCQUF3QixDQUFDO0FBQzFELE1BQU0sSUFBSSxHQUFHLHFCQUFxQixD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LEdBQUdBLE9BQU9BLENBQUNBLFFBQVFBLEVBQUVBLENBQUNBO1lBQ2xDQSxDQUFDQTtZQUFDQSxJQUFJQSxDQUFDQSxDQUFDQTtnQkFDTkEsT0FBT0EsR0FBR0EsSUFBSUEsMEJBQTBCQSxDQUNwQ0EsVUFBVUEsRUFBRUEsR0FBR0EsV0FBV0EsR0FBR0EsSUFBSUEsRUFBRUEsRUFDbkNBLEdBQUdBLCtCQUErQkEsR0FBR0Esd0JBQXdCQSxFQUFFQSxFQUMvREEsR0FBR0EsZ0JBQWdCQSxHQUFHQSxxQkFBcUJBLEVBQUVBLENBQUNBLENBQUNBO2dCQUNuREEsU0FBU0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsMkJBQTJCQSxPQUFPQSxDQUFDQSxRQUFRQSxPQUFPQSxDQUFDQSxDQUFDQTtnQkFDbkVBLFVBQVVBLEdBQUdBLE9BQU9BLENBQUNBLGNBQWNBLEVBQUVBLENBQUNBO1lBQ3hDQSxDQUFDQTtZQUNEQSxLQUFLQSxFQUFFQSxDQUFDQTtZQUNSQSxNQUFNQSxDQUFDQSxVQUFVQSxDQUFDQTtRQUNwQkEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDSEEsTUFBTUEsQ0FBQ0EsSUFBSUEsaUJBQWlCQSxDQUFDQSxXQUFXQSxFQUFFQSxTQUFTQSxDQUFDQSxDQUFDQTtJQUN2REEsQ0FBQ0E7QUFDSEosQ0FBQ0E7QUFyREQ7SUFBQyxVQUFVLEVBQUU7OzRCQXFEWjtBQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21waWxlVHlwZU1ldGFkYXRhfSBmcm9tICcuL2RpcmVjdGl2ZV9tZXRhZGF0YSc7XG5pbXBvcnQge1NvdXJjZUV4cHJlc3Npb25zLCBtb2R1bGVSZWZ9IGZyb20gJy4vc291cmNlX21vZHVsZSc7XG5pbXBvcnQge0NoYW5nZURldGVjdG9ySklUR2VuZXJhdG9yfSBmcm9tICdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb25faml0X2dlbmVyYXRvcic7XG5pbXBvcnQge0Fic3RyYWN0Q2hhbmdlRGV0ZWN0b3J9IGZyb20gJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yJztcbmltcG9ydCB7Q2hhbmdlRGV0ZWN0aW9uVXRpbH0gZnJvbSAnYW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwnO1xuaW1wb3J0IHtDaGFuZ2VEZXRlY3RvclN0YXRlfSBmcm9tICdhbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7Y3JlYXRlQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uc30gZnJvbSAnLi9jaGFuZ2VfZGVmaW5pdGlvbl9mYWN0b3J5JztcbmltcG9ydCB7SVNfREFSVCwgaXNKc09iamVjdCwgQ09OU1RfRVhQUn0gZnJvbSAnYW5ndWxhcjIvc3JjL2ZhY2FkZS9sYW5nJztcblxuaW1wb3J0IHtDaGFuZ2VEZXRlY3RvckdlbkNvbmZpZywgQ2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9uLCBEeW5hbWljUHJvdG9DaGFuZ2VEZXRlY3RvciwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3l9IGZyb20gJ2FuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbic7XG5cbmltcG9ydCB7VGVtcGxhdGVBc3R9IGZyb20gJy4vdGVtcGxhdGVfYXN0JztcbmltcG9ydCB7Q29kZWdlbn0gZnJvbSAnYW5ndWxhcjIvc3JjL3RyYW5zZm9ybS90ZW1wbGF0ZV9jb21waWxlci9jaGFuZ2VfZGV0ZWN0b3JfY29kZWdlbic7XG5pbXBvcnQge01PRFVMRV9TVUZGSVh9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJztcblxuY29uc3QgQUJTVFJBQ1RfQ0hBTkdFX0RFVEVDVE9SID0gJ0Fic3RyYWN0Q2hhbmdlRGV0ZWN0b3InO1xuY29uc3QgVVRJTCA9ICdDaGFuZ2VEZXRlY3Rpb25VdGlsJztcbmNvbnN0IENIQU5HRV9ERVRFQ1RPUl9TVEFURSA9ICdDaGFuZ2VEZXRlY3RvclN0YXRlJztcblxuZXhwb3J0IGNvbnN0IENIQU5HRV9ERVRFQ1RJT05fSklUX0lNUE9SVFMgPSBDT05TVF9FWFBSKHtcbiAgJ0Fic3RyYWN0Q2hhbmdlRGV0ZWN0b3InOiBBYnN0cmFjdENoYW5nZURldGVjdG9yLFxuICAnQ2hhbmdlRGV0ZWN0aW9uVXRpbCc6IENoYW5nZURldGVjdGlvblV0aWwsXG4gICdDaGFuZ2VEZXRlY3RvclN0YXRlJzogQ2hhbmdlRGV0ZWN0b3JTdGF0ZVxufSk7XG5cbnZhciBBQlNUUkFDVF9DSEFOR0VfREVURUNUT1JfTU9EVUxFID0gbW9kdWxlUmVmKFxuICAgIGBwYWNrYWdlOmFuZ3VsYXIyL3NyYy9jb3JlL2NoYW5nZV9kZXRlY3Rpb24vYWJzdHJhY3RfY2hhbmdlX2RldGVjdG9yJHtNT0RVTEVfU1VGRklYfWApO1xudmFyIFVUSUxfTU9EVUxFID1cbiAgICBtb2R1bGVSZWYoYHBhY2thZ2U6YW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwke01PRFVMRV9TVUZGSVh9YCk7XG52YXIgUFJFR0VOX1BST1RPX0NIQU5HRV9ERVRFQ1RPUl9NT0RVTEUgPSBtb2R1bGVSZWYoXG4gICAgYHBhY2thZ2U6YW5ndWxhcjIvc3JjL2NvcmUvY2hhbmdlX2RldGVjdGlvbi9wcmVnZW5fcHJvdG9fY2hhbmdlX2RldGVjdG9yJHtNT0RVTEVfU1VGRklYfWApO1xudmFyIENPTlNUQU5UU19NT0RVTEUgPVxuICAgIG1vZHVsZVJlZihgcGFja2FnZTphbmd1bGFyMi9zcmMvY29yZS9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cyR7TU9EVUxFX1NVRkZJWH1gKTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENoYW5nZURldGVjdGlvbkNvbXBpbGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZ2VuQ29uZmlnOiBDaGFuZ2VEZXRlY3RvckdlbkNvbmZpZykge31cblxuICBjb21waWxlQ29tcG9uZW50UnVudGltZShcbiAgICAgIGNvbXBvbmVudFR5cGU6IENvbXBpbGVUeXBlTWV0YWRhdGEsIHN0cmF0ZWd5OiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgIHBhcnNlZFRlbXBsYXRlOiBUZW1wbGF0ZUFzdFtdKTogRnVuY3Rpb25bXSB7XG4gICAgdmFyIGNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMgPVxuICAgICAgICBjcmVhdGVDaGFuZ2VEZXRlY3RvckRlZmluaXRpb25zKGNvbXBvbmVudFR5cGUsIHN0cmF0ZWd5LCB0aGlzLl9nZW5Db25maWcsIHBhcnNlZFRlbXBsYXRlKTtcbiAgICByZXR1cm4gY2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucy5tYXAoXG4gICAgICAgIGRlZmluaXRpb24gPT4gdGhpcy5fY3JlYXRlQ2hhbmdlRGV0ZWN0b3JGYWN0b3J5KGRlZmluaXRpb24pKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NyZWF0ZUNoYW5nZURldGVjdG9yRmFjdG9yeShkZWZpbml0aW9uOiBDaGFuZ2VEZXRlY3RvckRlZmluaXRpb24pOiBGdW5jdGlvbiB7XG4gICAgdmFyIHByb3RvID0gbmV3IER5bmFtaWNQcm90b0NoYW5nZURldGVjdG9yKGRlZmluaXRpb24pO1xuICAgIHJldHVybiAoKSA9PiBwcm90by5pbnN0YW50aWF0ZSgpO1xuICB9XG5cbiAgY29tcGlsZUNvbXBvbmVudENvZGVHZW4oXG4gICAgICBjb21wb25lbnRUeXBlOiBDb21waWxlVHlwZU1ldGFkYXRhLCBzdHJhdGVneTogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgICBwYXJzZWRUZW1wbGF0ZTogVGVtcGxhdGVBc3RbXSk6IFNvdXJjZUV4cHJlc3Npb25zIHtcbiAgICB2YXIgY2hhbmdlRGV0ZWN0b3JEZWZpbml0aW9ucyA9XG4gICAgICAgIGNyZWF0ZUNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMoY29tcG9uZW50VHlwZSwgc3RyYXRlZ3ksIHRoaXMuX2dlbkNvbmZpZywgcGFyc2VkVGVtcGxhdGUpO1xuICAgIHZhciBmYWN0b3JpZXMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2VQYXJ0cyA9IGNoYW5nZURldGVjdG9yRGVmaW5pdGlvbnMubWFwKGRlZmluaXRpb24gPT4ge1xuICAgICAgdmFyIGNvZGVnZW46IGFueTtcbiAgICAgIHZhciBzb3VyY2VQYXJ0OiBzdHJpbmc7XG4gICAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgdGhlIDIgY29kZSBnZW5lcmF0b3JzIHRvIHRoZSBzYW1lIHBsYWNlLCBvbmUgd2l0aCAuZGFydCBhbmQgb25lIHdpdGggLnRzXG4gICAgICAvLyBzdWZmaXhcbiAgICAgIC8vIGFuZCBoYXZlIHRoZSBzYW1lIEFQSSBmb3IgY2FsbGluZyB0aGVtIVxuICAgICAgaWYgKElTX0RBUlQpIHtcbiAgICAgICAgY29kZWdlbiA9IG5ldyBDb2RlZ2VuKFBSRUdFTl9QUk9UT19DSEFOR0VfREVURUNUT1JfTU9EVUxFKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGBfJHtkZWZpbml0aW9uLmlkfWA7XG4gICAgICAgIHZhciB0eXBlUmVmID0gKGluZGV4ID09PSAwICYmIGNvbXBvbmVudFR5cGUuaXNIb3N0KSA/XG4gICAgICAgICAgICAnZHluYW1pYycgOlxuICAgICAgICAgICAgYCR7bW9kdWxlUmVmKGNvbXBvbmVudFR5cGUubW9kdWxlVXJsKX0ke2NvbXBvbmVudFR5cGUubmFtZX1gO1xuICAgICAgICBjb2RlZ2VuLmdlbmVyYXRlKHR5cGVSZWYsIGNsYXNzTmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIGZhY3Rvcmllcy5wdXNoKGAke2NsYXNzTmFtZX0ubmV3Q2hhbmdlRGV0ZWN0b3JgKTtcbiAgICAgICAgc291cmNlUGFydCA9IGNvZGVnZW4udG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVnZW4gPSBuZXcgQ2hhbmdlRGV0ZWN0b3JKSVRHZW5lcmF0b3IoXG4gICAgICAgICAgICBkZWZpbml0aW9uLCBgJHtVVElMX01PRFVMRX0ke1VUSUx9YCxcbiAgICAgICAgICAgIGAke0FCU1RSQUNUX0NIQU5HRV9ERVRFQ1RPUl9NT0RVTEV9JHtBQlNUUkFDVF9DSEFOR0VfREVURUNUT1J9YCxcbiAgICAgICAgICAgIGAke0NPTlNUQU5UU19NT0RVTEV9JHtDSEFOR0VfREVURUNUT1JfU1RBVEV9YCk7XG4gICAgICAgIGZhY3Rvcmllcy5wdXNoKGBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyAke2NvZGVnZW4udHlwZU5hbWV9KCk7IH1gKTtcbiAgICAgICAgc291cmNlUGFydCA9IGNvZGVnZW4uZ2VuZXJhdGVTb3VyY2UoKTtcbiAgICAgIH1cbiAgICAgIGluZGV4Kys7XG4gICAgICByZXR1cm4gc291cmNlUGFydDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNvdXJjZUV4cHJlc3Npb25zKHNvdXJjZVBhcnRzLCBmYWN0b3JpZXMpO1xuICB9XG59XG4iXX0=